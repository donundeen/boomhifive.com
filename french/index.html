<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>French Learning Flashcards</title>
    <script src="https://code.responsivevoice.org/responsivevoice.js?key=zPY6ttoC"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            width: 100%;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .nav-menu {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px 0;
            text-align: center;
        }

        .nav-menu a {
            color: white;
            text-decoration: none;
            font-weight: 600;
            font-size: 16px;
            padding: 10px 20px;
            margin: 0 10px;
            border-radius: 25px;
            transition: all 0.3s ease;
            display: inline-block;
        }

        .nav-menu a:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .nav-menu a.active {
            background: rgba(255, 255, 255, 0.3);
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .controls {
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .control-group label {
            font-weight: 600;
            color: #495057;
            min-width: 120px;
        }

        select, button {
            padding: 10px 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        select:focus, button:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        button:hover {
            background: #4facfe;
            color: white;
            border-color: #4facfe;
        }

        /* Hamburger menu styles */
        .hamburger-menu {
            display: none;
            position: relative;
        }

        .hamburger-btn {
            background: #4facfe;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .hamburger-btn:hover {
            background: #3a8bfe;
        }

        .menu-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            z-index: 1000;
            padding: 15px;
        }

        .menu-content.show {
            display: block;
        }

        .menu-control-group {
            margin-bottom: 15px;
        }

        .menu-control-group:last-child {
            margin-bottom: 0;
        }

        .menu-control-group label {
            display: block;
            font-weight: 600;
            color: #495057;
            margin-bottom: 5px;
        }

        .menu-control-group select {
            width: 100%;
        }

        .menu-control-group button {
            width: 100%;
        }

        /* Action buttons layout */
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .correct-incorrect-buttons {
            display: flex;
            gap: 10px;
            width: 100%;
            margin-bottom: 15px;
        }

        .correct-btn, .incorrect-btn {
            flex: 1;
            padding: 15px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .correct-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
        }

        .correct-btn:hover {
            background: linear-gradient(135deg, #218838 0%, #1ea085 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
        }

        .incorrect-btn {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
            color: white;
        }

        .incorrect-btn:hover {
            background: linear-gradient(135deg, #c82333 0%, #b21e2b 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.3);
        }

        .navigation-buttons {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        .nav-btn {
            flex: 1;
            padding: 12px 20px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            background: white;
            color: #495057;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: #4facfe;
            color: white;
            border-color: #4facfe;
        }

        /* Speak buttons layout */
        .speak-buttons {
            display: flex;
            gap: 10px;
            width: 100%;
            margin-top: 15px;
        }

        .speak-btn {
            flex: 1;
            padding: 12px 20px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            border: none;
            cursor: pointer;
            text-align: center;
        }

        .speak-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
            background: linear-gradient(135deg, #218838 0%, #1ea085 100%);
        }

        .speak-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(40, 167, 69, 0.3);
        }

        .speak-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-top: 10px;
        }

        .stat {
            background: white;
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid #dee2e6;
            text-align: center;
        }

        .stat-number {
            font-size: 1.5em;
            font-weight: bold;
            color: #4facfe;
        }

        .stat-label {
            font-size: 0.8em;
            color: #6c757d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .flashcard-container {
            padding: 40px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 400px;
        }

        .card-legend {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 15px 25px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            border: 1px solid #e9ecef;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
            color: #495057;
        }

        .legend-key {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 4px 8px;
            font-weight: bold;
            color: #495057;
            font-size: 0.8em;
            min-width: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .legend-key:hover {
            background: #e9ecef;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .legend-key:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .flashcard {
            width: 100%;
            max-width: 600px;
            height: 350px;
            perspective: 1000px;
            cursor: pointer;
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            text-align: center;
            transition: transform 0.6s;
            transform-style: preserve-3d;
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
        }

        .flashcard.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 40px;
        }

        .card-front {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .card-back {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            transform: rotateY(180deg);
        }

        .word {
            font-size: 2.5em;
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .example {
            font-size: 1.2em;
            line-height: 1.6;
            opacity: 0.9;
            max-width: 90%;
        }

        .grammar-info {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 10px;
            font-style: italic;
            max-width: 90%;
        }

        .learn-more-container {
            margin-top: 20px;
            text-align: center;
        }

        .learn-more-link {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.3);
        }

        .learn-more-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(79, 172, 254, 0.4);
            background: linear-gradient(135deg, #3a8bfe 0%, #00d4fe 100%);
        }

        .learn-more-link:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(79, 172, 254, 0.3);
        }

        .speak-btn {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.3);
            border: none;
            cursor: pointer;
            margin-right: 15px;
        }

        .speak-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.4);
            background: linear-gradient(135deg, #218838 0%, #1ea085 100%);
        }

        .speak-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(40, 167, 69, 0.3);
        }

        .speak-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }



        .no-cards {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
            font-size: 1.2em;
        }

        .no-cards h2 {
            margin-bottom: 20px;
            color: #495057;
        }

        .reset-btn {
            background: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin-left: 10px;
        }

        .reset-btn:hover {
            background: #c82333;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.3);
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                padding: 15px;
            }
            
            .control-group {
                display: none;
            }
            
            .hamburger-menu {
                display: block;
            }
            
            .flashcard-container {
                padding: 20px;
            }
            
            .card-legend {
                display: none;
            }
            
            .word {
                font-size: 2em;
            }
            
            .example {
                font-size: 1em;
            }
            
            .grammar-info {
                font-size: 0.8em;
            }
            
            .learn-more-link {
                padding: 8px 16px;
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav-menu">
            <a href="index.html" class="active">üìö Flashcards</a>
            <a href="taboo.html">üéØ Taboo Game</a>
        </div>
        
        <div class="header">
            <h1>üá´üá∑ French Learning Flashcards</h1>
        </div>

        <div class="controls">
            <!-- Desktop controls -->
            <div class="control-group">
                <label for="fileSelect">Select Category:</label>
                <select id="fileSelect">
                    <option value="">Choose a category...</option>
                </select>
            </div>

            <div class="control-group">
                <label for="sideSelect">Show First:</label>
                <select id="sideSelect">
                    <option value="french">French</option>
                    <option value="english">English</option>
                    <option value="random">Random</option>
                </select>
                <button id="resetScoreBtn" class="reset-btn">Reset Score</button>
            </div>

            <!-- Mobile hamburger menu -->
            <div class="hamburger-menu">
                <button class="hamburger-btn" id="hamburgerBtn">
                    ‚ò∞ Menu
                </button>
                <div class="menu-content" id="menuContent">
                    <div class="menu-control-group">
                        <label for="fileSelectMobile">Select Category:</label>
                        <select id="fileSelectMobile">
                            <option value="">Choose a category...</option>
                        </select>
                    </div>
                    <div class="menu-control-group">
                        <label for="sideSelectMobile">Show First:</label>
                        <select id="sideSelectMobile">
                            <option value="french">French</option>
                            <option value="english">English</option>
                            <option value="random">Random</option>
                        </select>
                    </div>
                    <div class="menu-control-group">
                        <button id="resetScoreBtnMobile" class="reset-btn">Reset Score</button>
                    </div>
                </div>
            </div>

            <div class="stats">
                <div class="stat">
                    <div class="stat-number" id="totalCards">0</div>
                    <div class="stat-label">Total Cards</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="remainingCards">0</div>
                    <div class="stat-label">Remaining</div>
                </div>
                <div class="stat">
                    <div class="stat-number" id="correctCards">0</div>
                    <div class="stat-label">Correct</div>
                </div>
            </div>
        </div>

        <div class="flashcard-container">
            <!-- Desktop legend -->
            <div class="card-legend">
                <div class="legend-item">
                    <span class="legend-key" data-action="previous">‚Üê</span>
                    <span>Previous</span>
                </div>
                <div class="legend-item">
                    <span class="legend-key" data-action="next">‚Üí</span>
                    <span>Next</span>
                </div>
                <div class="legend-item">
                    <span class="legend-key" data-action="flip">Space</span>
                    <span>Flip</span>
                </div>
                <div class="legend-item">
                    <span class="legend-key" data-action="correct">A</span>
                    <span>Correct</span>
                </div>
                <div class="legend-item">
                    <span class="legend-key" data-action="incorrect">X</span>
                    <span>Incorrect</span>
                </div>
                <div class="legend-item">
                    <span class="legend-key" data-action="speak">S</span>
                    <span>Speak</span>
                </div>
            </div>

            <!-- Mobile action buttons -->
            <div class="action-buttons">
                <div class="navigation-buttons">
                    <button id="previousBtn" class="nav-btn">‚Üê Previous</button>
                    <button id="nextBtn" class="nav-btn">Next ‚Üí</button>
                </div>
                <div class="correct-incorrect-buttons">
                    <button id="correctBtn" class="correct-btn">‚úì Correct</button>
                    <button id="incorrectBtn" class="incorrect-btn">‚úó Incorrect</button>
                </div>
            </div>

            <div id="flashcard" class="flashcard">
                <div class="card-inner">
                    <div class="card-front">
                        <div class="word" id="frontWord">Select a category to start</div>
                        <div class="example" id="frontExample"></div>
                        <div class="grammar-info" id="frontGrammarInfo"></div>
                    </div>
                    <div class="card-back">
                        <div class="word" id="backWord"></div>
                        <div class="example" id="backExample"></div>
                        <div class="grammar-info" id="backGrammarInfo"></div>
                    </div>
                </div>
            </div>
            
            <div class="learn-more-container">
                <div class="speak-buttons">
                    <button id="speakBtn" class="speak-btn">üîä Speak French</button>
                    <button id="speakEnglishBtn" class="speak-btn">üîä Speak English</button>
                </div>
                <button id="forceStopBtn" class="speak-btn" style="display: none; background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);">‚èπÔ∏è Force Stop</button>
                <button id="hideTextBtn" class="speak-btn">üëÅÔ∏è Hide Text</button>
                <button id="showTextBtn" class="speak-btn" style="display: none;">üëÅÔ∏è Show Text</button>
                <a href="#" id="learnMoreLink" target="_blank" class="learn-more-link">Learn More</a>
            </div>
        </div>


    </div>

    <script>
      let FRENCH_NOUNS_DATA = [];
      let FRENCH_ADJECTIVES_DATA = [];
      let FRENCH_ADVERBS_DATA = [];
      let FRENCH_CONNECTING_WORDS_DATA = [];
      let FRENCH_PREPOSITIONS_DATA = [];
      let FRENCH_IRREGULAR_VERBS_DATA = [];
      let FRENCH_VERBS_DATA = [];
      let FRENCH_VERSATILE_WORDS_DATA = [];
      let THE_V_VERBS_DATA = [];
      let TEFAQ_VOCAB_FINAL_DATA = [];
      let PHRASES_FOR_LEARNING_DATA = [];
      // get from json file
      fetch('french_nouns.json')
        .then(response => response.json())
        .then(data => {
          FRENCH_NOUNS_DATA = data;
        });

      fetch('french_adjectives.json')
        .then(response => response.json())
        .then(data => {
          FRENCH_ADJECTIVES_DATA = data;
        });

      fetch('french_adverbs.json')
        .then(response => response.json())
        .then(data => {
          FRENCH_ADVERBS_DATA = data;
        });

      fetch('french_connecting_words.json')
        .then(response => response.json())
        .then(data => {
          FRENCH_CONNECTING_WORDS_DATA = data;
        });

      fetch('french_prepositions.json')
        .then(response => response.json())
        .then(data => {
          FRENCH_PREPOSITIONS_DATA = data;
        });

      fetch('french_irregular_verbs.json')
        .then(response => response.json())
        .then(data => {
          FRENCH_IRREGULAR_VERBS_DATA = data;
        });

      fetch('french_verbs.json')
        .then(response => response.json())
        .then(data => {
          FRENCH_VERBS_DATA = data;
        });

      fetch('french_versatile_words.json')
        .then(response => response.json())
        .then(data => {
          FRENCH_VERSATILE_WORDS_DATA = data;
        });

      fetch('the_v_verbs.json')
        .then(response => response.json())
        .then(data => {
          THE_V_VERBS_DATA = data;
        });

      fetch('tefaq_vocab_final.json')
        .then(response => response.json())
        .then(data => {
          TEFAQ_VOCAB_FINAL_DATA = data;
        });

      fetch('phrases_for_learning.json')
        .then(response => response.json())
        .then(data => {
          PHRASES_FOR_LEARNING_DATA = data;
        });




        class FlashcardApp {
            /**
             * Constructor - Initializes the FlashcardApp with default values and sets up the application
             * Sets up all necessary properties, initializes DOM elements, binds event listeners,
             * populates dropdown menus, and updates statistics display
             */
            constructor() {
                this.cards = [];
                this.shuffledCards = []; // New: shuffled deck for sequential navigation
                this.currentIndex = 0; // New: current position in shuffled deck
                this.currentCard = null; // Initialize currentCard
                this.correctCards = new Set();
                this.isFlipped = false;
                this.currentSide = 'french';
                this.cardHistory = [];
                this.historyIndex = -1;
                
                // Speech synthesis state
                this.isSpeaking = false;
                
                // Track which select was last used
                this.lastUsedSelect = 'desktop'; // 'desktop' or 'mobile'
                
                // Flag to prevent recursive calls when programmatically updating dropdowns
                this.isUpdatingDropdowns = false;

                // Category definitions with display names
                this.categories = [
                    { value: 'french_nouns.json', name: 'Nouns' },
                    { value: 'french_adjectives.json', name: 'Adjectives' },
                    { value: 'french_adverbs.json', name: 'Adverbs' },
                    { value: 'french_connecting_words.json', name: 'Connecting Words' },
                    { value: 'french_prepositions.json', name: 'Prepositions' },
                    { value: 'french_irregular_verbs.json', name: 'Irregular Verbs' },
                    { value: 'french_verbs.json', name: 'Verbs' },
                    { value: 'french_versatile_words.json', name: 'Versatile Words' },
                    { value: 'prepositions_with_verbs.json', name: 'Prepositions with Verbs' },
                    { value: 'the_v_verbs.json', name: 'V Verbs (Aller, Vouloir, Voir, Avoir)' },
                    { value: 'tefaq_vocab_final.json', name: 'TEFaQ Vocabulary' },
                    { value: 'phrases_for_learning.json', name: 'Learning Phrases' },
                    { value: 'asking_questions.json', name: 'Asking Questions (TEFaQ Part A)' },
                    { value: 'oral_expression_section_b.json', name: 'Oral Expression Section B' },
                    { value: 'chat_review.json', name: 'Chat Review (TEFaQ Part A)' },
                    { value: 'class_vocab_flashcards.json', name: 'Class Vocabulary Flashcards' }
                ];

                this.initializeElements();
                this.bindEvents();
                this.populateDropdowns();
                this.updateStats();
            }

            /**
             * Initializes all DOM element references needed by the application
             * Gets references to file selectors, side selectors, flashcard container,
             * buttons, progress indicators, and other UI elements
             */
            initializeElements() {
                this.fileSelect = document.getElementById('fileSelect');
                this.sideSelect = document.getElementById('sideSelect');
                this.flashcard = document.getElementById('flashcard');
                this.frontWord = document.getElementById('frontWord');
                this.frontExample = document.getElementById('frontExample');
                this.frontGrammarInfo = document.getElementById('frontGrammarInfo');
                this.backWord = document.getElementById('backWord');
                this.backExample = document.getElementById('backExample');
                this.backGrammarInfo = document.getElementById('backGrammarInfo');
                this.totalCardsEl = document.getElementById('totalCards');
                this.remainingCardsEl = document.getElementById('remainingCards');
                this.correctCardsEl = document.getElementById('correctCards');
                this.learnMoreLink = document.getElementById('learnMoreLink');
                this.speakBtn = document.getElementById('speakBtn');
                this.speakEnglishBtn = document.getElementById('speakEnglishBtn');
                this.forceStopBtn = document.getElementById('forceStopBtn');
                this.hideTextBtn = document.getElementById('hideTextBtn');
                this.showTextBtn = document.getElementById('showTextBtn');
                
                // Mobile elements
                this.hamburgerBtn = document.getElementById('hamburgerBtn');
                this.menuContent = document.getElementById('menuContent');
                this.fileSelectMobile = document.getElementById('fileSelectMobile');
                this.sideSelectMobile = document.getElementById('sideSelectMobile');
                this.resetScoreBtnMobile = document.getElementById('resetScoreBtnMobile');
                this.correctBtn = document.getElementById('correctBtn');
                this.incorrectBtn = document.getElementById('incorrectBtn');
                this.previousBtn = document.getElementById('previousBtn');
                this.nextBtn = document.getElementById('nextBtn');
            }

            /**
             * Binds all event listeners to DOM elements
             * Sets up event handlers for file selection, side selection, button clicks,
             * keyboard navigation, hamburger menu, and other user interactions
             */
            bindEvents() {
                // Desktop events
                this.fileSelect.addEventListener('change', () => {
                    this.lastUsedSelect = 'desktop';
                    this.loadCards();
                });
                this.sideSelect.addEventListener('change', () => {
                    this.lastUsedSelect = 'desktop';
                    this.updateCurrentSide();
                });
                this.flashcard.addEventListener('click', () => this.flipCard());
                this.speakBtn.addEventListener('click', () => this.speakText('french'));
                this.speakEnglishBtn.addEventListener('click', () => this.speakText('english'));
                this.forceStopBtn.addEventListener('click', () => this.forceStopSpeech());
                this.hideTextBtn.addEventListener('click', () => this.hideText());
                this.showTextBtn.addEventListener('click', () => this.showText());
                document.getElementById('resetScoreBtn').addEventListener('click', () => this.resetScore());
                
                // Mobile events
                this.hamburgerBtn.addEventListener('click', () => this.toggleHamburgerMenu());
                this.fileSelectMobile.addEventListener('change', () => {
                    this.lastUsedSelect = 'mobile';
                    this.loadCards();
                });
                this.sideSelectMobile.addEventListener('change', () => {
                    this.lastUsedSelect = 'mobile';
                    this.updateCurrentSide();
                });
                this.resetScoreBtnMobile.addEventListener('click', () => this.resetScore());
                this.correctBtn.addEventListener('click', () => this.markAsCorrect());
                this.incorrectBtn.addEventListener('click', () => this.markAsIncorrect());
                this.previousBtn.addEventListener('click', () => this.showPreviousCard());
                this.nextBtn.addEventListener('click', () => this.advanceToNextCard());
                
                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // Add click handlers for legend keys
                document.querySelectorAll('.legend-key').forEach(key => {
                    key.addEventListener('click', (e) => {
                        e.preventDefault();
                        const action = key.getAttribute('data-action');
                        this.handleLegendClick(action);
                    });
                });
                
                // Close hamburger menu when clicking outside
                document.addEventListener('click', (e) => {
                    if (!this.hamburgerBtn.contains(e.target) && !this.menuContent.contains(e.target)) {
                        this.menuContent.classList.remove('show');
                    }
                });
                
                // Save progress when page is about to unload
                window.addEventListener('beforeunload', () => this.saveProgress());
            }

            /**
             * Populates both desktop and mobile dropdown menus with available categories
             * Calls populateDropdown for both select elements to ensure consistency
             * @param {string} preserveValue - Optional value to preserve in both dropdowns
             */
            populateDropdowns(preserveValue = null) {
                const valueToPreserve = preserveValue || this.fileSelect.value || this.fileSelectMobile.value;
                
                // Set flag once for the entire operation
                this.isUpdatingDropdowns = true;
                
                this.populateDropdown(this.fileSelect, valueToPreserve);
                this.populateDropdown(this.fileSelectMobile, valueToPreserve);
                
                // Clear the flag after both dropdowns are updated
                setTimeout(() => {
                    this.isUpdatingDropdowns = false;
                }, 50);
            }

            /**
             * Populates a dropdown select element with available categories and their progress
             * Clears existing options, adds categories with progress indicators (correct/total),
             * and preserves the current selection if it's still valid
             * @param {HTMLSelectElement} selectElement - The select element to populate
             * @param {string} preserveValue - Optional value to preserve (overrides reading from selectElement)
             */
            populateDropdown(selectElement, preserveValue = null) {
                // Store the selection to preserve - use provided value or read from element
                const currentSelection = preserveValue !== null ? preserveValue : selectElement.value;
                
                // Clear existing options except the first one
                selectElement.innerHTML = '<option value="">Choose a category...</option>';
                
                // Add options for each category with progress information
                this.categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category.value;
                    
                    // Get progress for this category
                    const progress = this.getCategoryProgress(category.value);
                    const progressText = progress.total > 0 ? ` (${progress.correct}/${progress.total})` : '';
                    
                    option.textContent = category.name + progressText;
                    selectElement.appendChild(option);
                });
                
                // Restore the selection if it still exists
                // Use setTimeout to ensure DOM is fully updated, especially for mobile dropdowns
                if (currentSelection && this.categories.some(cat => cat.value === currentSelection)) {
                    // Set immediately
                    selectElement.value = currentSelection;
                    // Also set after a brief delay to handle any timing issues with mobile menu
                    setTimeout(() => {
                        if (selectElement.value !== currentSelection) {
                            selectElement.value = currentSelection;
                        }
                    }, 0);
                }
            }

            /**
             * Retrieves the progress statistics for a specific category from localStorage
             * Returns an object with correct and total counts for the category
             * @param {string} categoryFile - The filename of the category to get progress for
             * @returns {Object} Object with correct and total properties
             */
            getCategoryProgress(categoryFile) {
                const savedProgress = localStorage.getItem(`flashcard_progress_${categoryFile}`);
                
                if (savedProgress) {
                    try {
                        const progress = JSON.parse(savedProgress);
                        const correct = progress.correctCards ? progress.correctCards.length : 0;
                        // Use stored totalCards if available, otherwise fall back to shuffledCards.length
                        const total = progress.totalCards || (progress.shuffledCards ? progress.shuffledCards.length : 0);
                        return { correct, total };
                    } catch (error) {
                        console.error('Error parsing progress for', categoryFile, ':', error);
                    }
                }
                
                return { correct: 0, total: 0 };
            }

            /**
             * Updates the progress display for the currently selected category in both dropdowns
             * Gets the current progress and updates the option text to show (correct/total) format
             * Only updates the currently selected category to avoid unnecessary DOM manipulation
             */
            updateCurrentCategoryProgress() {
                const selectedFile = this.fileSelect.value;
                if (!selectedFile) return;

                // Find the category name for the selected file
                const category = this.categories.find(cat => cat.value === selectedFile);
                if (!category) return;

                // Get current progress
                const progress = this.getCategoryProgress(selectedFile);
                const progressText = progress.total > 0 ? ` (${progress.correct}/${progress.total})` : '';
                const newText = category.name + progressText;

                // Update both desktop and mobile dropdowns
                [this.fileSelect, this.fileSelectMobile].forEach(select => {
                    const option = select.querySelector(`option[value="${selectedFile}"]`);
                    if (option) {
                        option.textContent = newText;
                    }
                });
            }

            /**
             * Toggles the mobile hamburger menu visibility
             * Adds or removes the 'active' class to show/hide the mobile navigation menu
             */
            toggleHamburgerMenu() {
                this.menuContent.classList.toggle('show');
            }

            /**
             * Loads flashcard data from the selected JSON file
             * Fetches the file, parses the JSON data, and merges with existing progress
             * Handles errors and updates the UI accordingly
             */
            loadCards() {
                // Prevent recursive calls when programmatically updating dropdowns
                if (this.isUpdatingDropdowns) return;
                
                // Get the selected file from the dropdown that was actually changed
                const selectedFile = this.lastUsedSelect === 'mobile' 
                    ? this.fileSelectMobile.value 
                    : (this.fileSelect.value || this.fileSelectMobile.value);
                
                if (!selectedFile) return;

                // Sync both selects, but only if they're different to avoid triggering events
                if (this.fileSelect.value !== selectedFile) {
                    this.isUpdatingDropdowns = true;
                    this.fileSelect.value = selectedFile;
                    setTimeout(() => { this.isUpdatingDropdowns = false; }, 10);
                }
                if (this.fileSelectMobile.value !== selectedFile) {
                    this.isUpdatingDropdowns = true;
                    this.fileSelectMobile.value = selectedFile;
                    setTimeout(() => { this.isUpdatingDropdowns = false; }, 10);
                }

                // Load data from external JSON file
                fetch(selectedFile)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        this.cards = data;
                        // Merge with existing progress and handle updates
                        this.mergeWithExistingProgress(selectedFile);
                        // Ensure stats are updated after merge (in case merge didn't call updateStats)
                        this.updateStats();
                        // Refresh dropdowns to show updated progress, explicitly preserving the selected file
                        this.populateDropdowns(selectedFile);
                        // Double-check that both dropdowns have the correct value after repopulation
                        // This is especially important for mobile dropdowns
                        setTimeout(() => {
                            if (this.fileSelect.value !== selectedFile) {
                                this.isUpdatingDropdowns = true;
                                this.fileSelect.value = selectedFile;
                                setTimeout(() => { this.isUpdatingDropdowns = false; }, 10);
                            }
                            if (this.fileSelectMobile.value !== selectedFile) {
                                this.isUpdatingDropdowns = true;
                                this.fileSelectMobile.value = selectedFile;
                                setTimeout(() => { this.isUpdatingDropdowns = false; }, 10);
                            }
                            // Final stats update to ensure everything is in sync
                            this.updateStats();
                        }, 100);
                    })
                    .catch(error => {
                        console.error('Error loading JSON file:', error);
                        this.showError('Error loading file. Please try again.');
                    });
            }

            /**
             * Determines whether to merge with existing progress or start fresh
             * Checks if there's saved progress and calls the appropriate method
             * @param {string} selectedFile - The filename of the selected category
             */
            mergeWithExistingProgress(selectedFile) {
                const savedProgress = localStorage.getItem(`flashcard_progress_${selectedFile}`);
                
                if (savedProgress) {
                    try {
                        const progress = JSON.parse(savedProgress);
                        
                        // Check if we have existing progress to merge
                        if (progress.shuffledCards && progress.shuffledCards.length > 0) {
                            this.mergeCardsWithProgress(progress);
                            return;
                        }
                    } catch (error) {
                        console.error('Error parsing existing progress:', error);
                    }
                }
                
                // No existing progress or error parsing, start fresh
                this.shuffleDeck();
                this.loadProgress(selectedFile);
            }

            /**
             * Merges new card data with existing user progress
             * Uses fresh JSON data as source of truth and maps existing progress to new deck
             * Handles cases where cards have been added, removed, or modified
             * @param {Object} existingProgress - The saved progress data from localStorage
             */
            mergeCardsWithProgress(existingProgress) {
                // Extract existing progress data
                const existingCorrectCards = new Set(existingProgress.correctCards || []);
                const existingCardHistory = existingProgress.cardHistory || [];
                const existingHistoryIndex = existingProgress.historyIndex || -1;
                const existingCurrentCard = existingProgress.currentCard;
                const existingCurrentSide = existingProgress.currentSide || 'french';
                
                // Create a map of existing correct cards by French word for lookup
                const existingCorrectCardsMap = new Map();
                if (existingProgress.shuffledCards) {
                    existingProgress.shuffledCards.forEach((card, index) => {
                        if (card && card.length > 0 && existingCorrectCards.has(index)) {
                            const frenchWord = card[0];
                            existingCorrectCardsMap.set(frenchWord, card);
                        }
                    });
                }
                
                // Create a map of existing history cards by French word
                const existingHistoryMap = new Map();
                if (existingProgress.shuffledCards) {
                    existingCardHistory.forEach(historyIndex => {
                        const card = existingProgress.shuffledCards[historyIndex];
                        if (card && card.length > 0) {
                            const frenchWord = card[0];
                            existingHistoryMap.set(frenchWord, card);
                        }
                    });
                }
                
                // Start fresh with the new JSON data
                this.shuffleDeck(); // This creates a new shuffled deck from this.cards
                
                // Map existing correct cards to new deck positions
                const newCorrectCards = new Set();
                this.shuffledCards.forEach((card, newIndex) => {
                    if (card && card.length > 0) {
                        const frenchWord = card[0];
                        if (existingCorrectCardsMap.has(frenchWord)) {
                            newCorrectCards.add(newIndex);
                        }
                    }
                });
                
                // Map existing history to new deck positions
                const newCardHistory = [];
                this.shuffledCards.forEach((card, newIndex) => {
                    if (card && card.length > 0) {
                        const frenchWord = card[0];
                        if (existingHistoryMap.has(frenchWord)) {
                            newCardHistory.push(newIndex);
                        }
                    }
                });
                
                // Find the current card in the new deck
                let newCurrentCard = null;
                if (existingCurrentCard !== null && existingCurrentCard !== undefined && existingProgress.shuffledCards) {
                    const oldCard = existingProgress.shuffledCards[existingCurrentCard];
                    if (oldCard && oldCard.length > 0) {
                        const frenchWord = oldCard[0];
                        const newIndex = this.shuffledCards.findIndex(card => 
                            card && card.length > 0 && card[0] === frenchWord
                        );
                        if (newIndex !== -1) {
                            newCurrentCard = newIndex;
                        }
                    }
                }
                
                // Update progress with mapped values
                this.correctCards = newCorrectCards;
                this.cardHistory = newCardHistory;
                this.historyIndex = newCardHistory.length - 1;
                this.currentCard = newCurrentCard;
                this.currentSide = existingCurrentSide;
                
                // If we couldn't find the current card, start from the beginning
                if (this.currentCard === null) {
                    this.currentIndex = 0;
                    this.currentCard = 0;
                } else {
                    // Ensure currentIndex is valid (not beyond deck size)
                    this.currentIndex = Math.min(this.currentCard, this.shuffledCards.length - 1);
                    this.currentCard = this.currentIndex;
                }
                
                // Update the side selectors to match saved preference
                this.sideSelect.value = this.currentSide;
                this.sideSelectMobile.value = this.currentSide;
                
                // Update stats - ensure this happens after all state is set
                this.updateStats();
                
                // Show the current card if it exists, otherwise show next
                if (this.currentCard !== null && this.currentCard !== undefined) {
                    this.displayCard();
                } else {
                    this.showNextCard();
                }
                
                // Save the merged progress
                this.saveProgress();
                
                // Log the merge results
                console.log(`Merged progress: ${newCorrectCards.size} correct cards, ${newCardHistory.length} history entries, current card: ${this.currentCard}`);
            }

            /**
             * Shuffles the current deck of cards using Fisher-Yates algorithm
             * Creates a new shuffled array while preserving the original cards array
             * Resets the current index to 0
             */
            shuffleDeck() {
                // Create a copy of the cards array and shuffle it
                this.shuffledCards = [...this.cards];
                for (let i = this.shuffledCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.shuffledCards[i], this.shuffledCards[j]] = [this.shuffledCards[j], this.shuffledCards[i]];
                }
                this.currentIndex = 0;
            }

            /**
             * Updates the current side preference based on the selected option
             * Syncs both desktop and mobile side selectors and updates the current side
             * Saves progress after updating the side preference
             */
            updateCurrentSide() {
                // Get the value from the select that was just used
                const newSide = this.lastUsedSelect === 'mobile' 
                    ? this.sideSelectMobile.value 
                    : this.sideSelect.value;
                
                this.currentSide = newSide;
                
                // Sync both selects to the same value
                this.sideSelect.value = newSide;
                this.sideSelectMobile.value = newSide;
                
                console.log('Language setting changed to:', newSide, 'via', this.lastUsedSelect);
                
                if (this.currentCard !== null && this.currentCard !== undefined) {
                    this.displayCard();
                }
                this.saveProgress();
            }

            /**
             * Shows the next card in the shuffled deck
             * Updates the current index, adds the current card to history, and displays the new card
             * Handles end of deck by showing completion message
             */
            showNextCard() {
                // Check if we're at the end of the deck
                if (this.currentIndex >= this.shuffledCards.length) {
                    this.showCompletionMessage();
                    return;
                }

                // Get the current card from the shuffled deck
                this.currentCard = this.currentIndex;
                this.isFlipped = false;
                this.flashcard.classList.remove('flipped');
                
                // Add to history only if we're not already at the end
                if (this.currentIndex < this.shuffledCards.length) {
                    this.cardHistory.push(this.currentCard);
                    this.historyIndex = this.cardHistory.length - 1;
                }
                
                this.displayCard();
                this.saveProgress();
                this.updateNavigationButtons();
            }

            /**
             * Advances to the next card in the deck (used by navigation buttons)
             * Increments currentIndex and shows the next card
             */
            advanceToNextCard() {
                if (this.currentIndex < this.shuffledCards.length - 1) {
                    // Add current card to history before advancing
                    if (this.currentCard !== null) {
                        this.cardHistory.push(this.currentCard);
                        this.historyIndex = this.cardHistory.length - 1;
                    }
                    
                    this.currentIndex++;
                    this.currentCard = this.currentIndex;
                    this.isFlipped = false;
                    this.flashcard.classList.remove('flipped');
                    this.displayCard();
                    this.saveProgress();
                } else {
                    this.showCompletionMessage();
                }
                this.updateNavigationButtons();
            }

            /**
             * Shows the previous card from the history
             * Decrements the history index and displays the previous card
             * Handles beginning of history by doing nothing
             */
            showPreviousCard() {
                // Check if we have history and can go back
                if (this.cardHistory.length > 0 && this.historyIndex > 0) {
                    this.historyIndex--;
                    this.currentCard = this.cardHistory[this.historyIndex];
                    // Restore the currentIndex to match the history position
                    this.currentIndex = this.currentCard;
                    this.isFlipped = false;
                    this.flashcard.classList.remove('flipped');
                    this.displayCard();
                    this.saveProgress();
                } else if (this.cardHistory.length > 0 && this.historyIndex === 0) {
                    // We're at the first card in history, stay there
                    this.currentCard = this.cardHistory[0];
                    this.currentIndex = this.currentCard;
                    this.isFlipped = false;
                    this.flashcard.classList.remove('flipped');
                    this.displayCard();
                    this.saveProgress();
                }
                // If no history exists, do nothing (we're at the beginning)
                this.updateNavigationButtons();
            }

            /**
             * Saves the current progress to localStorage
             * Stores shuffled cards, current position, correct cards, history, and other state
             * Updates the progress display for the current category
             */
            saveProgress() {
                const selectedFile = this.fileSelect.value;
                if (!selectedFile) return;

                const progress = {
                    shuffledCards: this.shuffledCards,
                    currentIndex: this.currentIndex,
                    correctCards: Array.from(this.correctCards),
                    cardHistory: this.cardHistory,
                    historyIndex: this.historyIndex,
                    currentCard: this.currentCard,
                    currentSide: this.currentSide,
                    totalCards: this.cards.length, // Store the actual total number of cards
                    timestamp: Date.now()
                };

                localStorage.setItem(`flashcard_progress_${selectedFile}`, JSON.stringify(progress));
                
                // Update the progress display for the currently selected category
                this.updateCurrentCategoryProgress();
            }

            /**
             * Loads saved progress from localStorage for a specific category
             * Restores shuffled cards, current position, correct cards, and history
             * Validates the saved data and falls back to fresh start if invalid
             * @param {string} selectedFile - The filename of the category to load progress for
             */
            loadProgress(selectedFile) {
                const savedProgress = localStorage.getItem(`flashcard_progress_${selectedFile}`);
                
                if (savedProgress) {
                    try {
                        const progress = JSON.parse(savedProgress);
                        
                        // Check if we have saved progress (even if deck size changed, we'll merge it)
                        if (progress.shuffledCards && progress.shuffledCards.length > 0) {
                            // If deck size matches, use saved shuffled deck directly
                            if (progress.shuffledCards.length === this.cards.length) {
                                this.shuffledCards = progress.shuffledCards;
                                this.currentIndex = Math.min(progress.currentIndex || 0, this.shuffledCards.length - 1);
                                this.correctCards = new Set(progress.correctCards || []);
                                this.cardHistory = progress.cardHistory || [];
                                this.historyIndex = progress.historyIndex || -1;
                                this.currentCard = progress.currentCard !== null && progress.currentCard !== undefined 
                                    ? Math.min(progress.currentCard, this.shuffledCards.length - 1) 
                                    : null;
                                this.currentSide = progress.currentSide || 'french';
                                
                                // Update the side selector to match saved preference
                                this.sideSelect.value = this.currentSide;
                                this.sideSelectMobile.value = this.currentSide;
                                
                                this.updateStats();
                                
                                // Show the current card if it exists, otherwise show next
                                if (this.currentCard !== null && this.currentCard !== undefined) {
                                    this.displayCard();
                                } else {
                                    this.showNextCard();
                                }
                                this.updateNavigationButtons();
                                return;
                            }
                            // If deck size doesn't match, the merge will be handled by mergeWithExistingProgress
                            // which calls mergeCardsWithProgress, so we should not reach here
                        }
                    } catch (error) {
                        console.error('Error loading progress:', error);
                    }
                }
                
                // If no valid saved progress, start fresh
                this.correctCards.clear();
                this.cardHistory = [];
                this.historyIndex = -1;
                this.currentIndex = 0;
                this.updateStats();
                this.showNextCard();
                this.updateNavigationButtons();
            }

            /**
             * Resets the progress for the current category
             * Clears localStorage, resets all progress tracking, and reshuffles the deck
             * Shows confirmation dialog before resetting
             */
            resetScore() {
                const selectedFile = this.fileSelect.value;
                if (!selectedFile) return;

                if (confirm('Are you sure you want to reset your progress for this category? This cannot be undone.')) {
                    // Clear localStorage for this category
                    localStorage.removeItem(`flashcard_progress_${selectedFile}`);
                    
                    // Reset current session
                    this.correctCards.clear();
                    this.shuffleDeck(); // Reshuffle the deck
                    this.cardHistory = [];
                    this.historyIndex = -1;
                    this.currentCard = null;
                    this.updateStats();
                    this.showNextCard();
                    
                    // Update the progress display for the reset category
                    this.updateCurrentCategoryProgress();
                }
            }

            /**
             * Displays the current card on the flashcard interface
             * Shows the appropriate side (French or English) based on user preference
             * Handles both 4-element and 5-element card formats
             */
            displayCard() {
                if (this.currentCard === null || this.currentCard === undefined) return;

                const card = this.shuffledCards[this.currentCard];
                if (!card) return;
                
                // Handle 2-element, 4-element, and 5-element arrays
                let frenchWord, englishWord, frenchExample, englishExample, grammarInfo;
                
                if (card.length === 5) {
                    [frenchWord, englishWord, frenchExample, englishExample, grammarInfo] = card;
                } else if (card.length === 4) {
                    [frenchWord, englishWord, frenchExample, englishExample] = card;
                    grammarInfo = null;
                } else if (card.length === 2) {
                    [frenchWord, englishWord] = card;
                    frenchExample = '';
                    englishExample = '';
                    grammarInfo = null;
                } else {
                    console.error('Invalid card format:', card);
                    return;
                }

                // Determine which side to show first
                let showFrenchFirst = this.currentSide === 'french' || 
                    (this.currentSide === 'random' && Math.random() < 0.5);

                if (showFrenchFirst) {
                    this.frontWord.textContent = frenchWord;
                    this.frontExample.textContent = frenchExample;
                    this.frontGrammarInfo.textContent = grammarInfo ? `(${grammarInfo})` : '';
                    this.backWord.textContent = englishWord;
                    this.backExample.textContent = englishExample;
                    this.backGrammarInfo.textContent = grammarInfo ? `(${grammarInfo})` : '';
                } else {
                    this.frontWord.textContent = englishWord;
                    this.frontExample.textContent = englishExample;
                    this.frontGrammarInfo.textContent = grammarInfo ? `(${grammarInfo})` : '';
                    this.backWord.textContent = frenchWord;
                    this.backExample.textContent = frenchExample;
                    this.backGrammarInfo.textContent = grammarInfo ? `(${grammarInfo})` : '';
                }

                // Update Learn More link
                this.updateLearnMoreLink(frenchWord);
            }

            /**
             * Flips the flashcard to show the opposite side
             * Toggles the 'flipped' class and updates the isFlipped state
             */
            flipCard() {
                this.isFlipped = !this.isFlipped;
                this.flashcard.classList.toggle('flipped', this.isFlipped);
            }

            /**
             * Marks the current card as correct and moves to the next card
             * Adds the card to the correct cards set and updates statistics
             * Saves progress and shows the next card
             */
            markAsCorrect() {
                if (this.currentCard === null) return;
                
                // Mark the current card as correct
                this.correctCards.add(this.currentCard);
                
                // Advance to the next card
                this.currentIndex++;
                
                this.updateStats();
                this.saveProgress();
                this.showNextCard();
                this.updateNavigationButtons();
            }

            /**
             * Marks the current card as incorrect and moves to the next card
             * Removes the card from correct cards set if it was previously marked correct
             * Updates statistics, saves progress, and shows the next card
             */
            markAsIncorrect() {
                if (this.currentCard === null) return;
                
                // Move the incorrect card 5-10 positions down in the deck
                const moveDistance = Math.floor(Math.random() * 6) + 5; // Random 5-10 positions
                const newPosition = Math.min(this.currentIndex + moveDistance, this.shuffledCards.length - 1);
                
                // Remove the card from its current position
                const incorrectCard = this.shuffledCards.splice(this.currentIndex, 1)[0];
                
                // Insert it at the new position
                this.shuffledCards.splice(newPosition, 0, incorrectCard);
                
                // The current card at the current index is now a new card
                // No need to advance the index - just display the new card
                
                this.updateStats();
                this.saveProgress();
                this.displayCard();
                this.updateNavigationButtons();
            }

            /**
             * Handles keyboard input for navigation and actions
             * Supports arrow keys for navigation, space/enter for flipping, and number keys for actions
             * @param {KeyboardEvent} event - The keyboard event to handle
             */
            handleKeyPress(event) {
                switch(event.key) {
                    case 'ArrowLeft':
                        event.preventDefault();
                        this.showPreviousCard();
                        break;
                    case 'ArrowRight':
                        event.preventDefault();
                        this.advanceToNextCard();
                        break;
                    case ' ':
                        event.preventDefault();
                        this.flipCard();
                        break;
                    case 'a':
                    case 'A':
                        event.preventDefault();
                        this.markAsCorrect();
                        break;
                    case 'x':
                    case 'X':
                        event.preventDefault();
                        this.markAsIncorrect();
                        break;
                }
            }

            /**
             * Handles clicks on the legend buttons for quick actions
             * Maps legend actions to corresponding methods
             * @param {string} action - The action to perform ('correct', 'incorrect', 'flip', 'next', 'previous')
             */
            handleLegendClick(action) {
                switch(action) {
                    case 'previous':
                        this.showPreviousCard();
                        break;
                    case 'next':
                        this.advanceToNextCard();
                        break;
                    case 'flip':
                        this.flipCard();
                        break;
                    case 'correct':
                        this.markAsCorrect();
                        break;
                    case 'incorrect':
                        this.markAsIncorrect();
                        break;
                }
            }

            /**
             * Updates the statistics display showing progress
             * Calculates and displays correct/total counts and percentage
             */
            updateStats() {
                // Ensure we have valid card data
                const totalCards = this.cards ? this.cards.length : 0;
                const correctCount = this.correctCards ? this.correctCards.size : 0;
                
                // Use the actual total from cards array (source of truth)
                this.totalCardsEl.textContent = totalCards;
                
                // Calculate remaining: cards not yet marked as correct
                // This ensures Remaining + Correct = Total
                const remaining = Math.max(0, totalCards - correctCount);
                this.remainingCardsEl.textContent = remaining;
                
                // Show correct count
                this.correctCardsEl.textContent = correctCount;
            }

            /**
             * Shows a completion message when all cards have been reviewed
             * Displays statistics and offers options to continue or reset
             */
            showCompletionMessage() {
                this.frontWord.textContent = 'üéâ Congratulations!';
                this.frontExample.textContent = `You've completed all ${this.cards.length} cards!`;
                this.frontGrammarInfo.textContent = '';
                this.backWord.textContent = '';
                this.backExample.textContent = '';
                this.backGrammarInfo.textContent = '';
                this.flashcard.classList.remove('flipped');
                
                // Hide Learn More link
                this.hideLearnMoreLink();
                
                // Add reset button
                const resetBtn = document.createElement('button');
                resetBtn.textContent = 'Start Over';
                resetBtn.className = 'reset-btn';
                resetBtn.style.marginTop = '20px';
                resetBtn.onclick = () => {
                    this.correctCards.clear();
                    this.shuffleDeck();
                    this.currentIndex = 0;
                    this.updateStats();
                    this.showNextCard();
                    resetBtn.remove();
                };
                
                const cardFront = this.flashcard.querySelector('.card-front');
                cardFront.appendChild(resetBtn);
            }

            /**
             * Displays an error message on the flashcard interface
             * Shows the error message and clears other content
             * @param {string} message - The error message to display
             */
            showError(message) {
                this.frontWord.textContent = '‚ùå Error';
                this.frontExample.textContent = message;
                this.frontGrammarInfo.textContent = '';
                this.backWord.textContent = '';
                this.backExample.textContent = '';
                this.backGrammarInfo.textContent = '';
                
                // Hide Learn More link
                this.hideLearnMoreLink();
            }

            /**
             * Updates the Learn More link with the current French word
             * Sets the href to search for the word on Reverso Context
             * @param {string} frenchWord - The French word to search for
             */
            updateLearnMoreLink(frenchWord) {
                if (this.learnMoreLink) {
                    const searchQuery = encodeURIComponent(`meaning and use of "${frenchWord}" in French`);
                    this.learnMoreLink.href = `https://www.google.com/search?q=${searchQuery}`;
                    this.learnMoreLink.style.display = 'inline-block';
                }
            }

            /**
             * Hides the Learn More link
             * Sets the display style to none to hide the link
             */
            hideLearnMoreLink() {
                if (this.learnMoreLink) {
                    this.learnMoreLink.style.display = 'none';
                }
            }

            /**
             * Removes parentheses and their contents from text
             * Used to clean up text for display purposes
             * @param {string} text - The text to clean
             * @returns {string} The text with parentheses removed
             */
            removeParentheses(text) {
                if (!text) return text;
                // Remove text within parentheses, including the parentheses themselves
                return text.replace(/\([^)]*\)/g, '').trim();
            }

            /**
             * Checks which speech synthesis options are available
             * Tests for ResponsiveVoice and Web Speech API availability
             * Logs the results for debugging purposes
             */
            checkAvailableVoices() {
                if (typeof responsiveVoice !== 'undefined') {
                    console.log('Available ResponsiveVoice voices:');
                    console.log(responsiveVoice.getVoices());
                    
                    // Also try to get voices using the standard Web Speech API for comparison
                    if ('speechSynthesis' in window) {
                        console.log('Web Speech API voices:');
                        const voices = window.speechSynthesis.getVoices();
                        console.log(voices.map(v => ({ name: v.name, lang: v.lang })));
                    }
                } else {
                    console.log('ResponsiveVoice not loaded');
                }
            }

            /**
             * Initiates text-to-speech for the current card
             * Determines which text to speak based on the current side and language
             * Handles both French and English speech synthesis
             * @param {string} language - The language to speak ('french' or 'english')
             */
            speakText(language = 'french') {
                if (this.currentCard === null) return;

                const card = this.shuffledCards[this.currentCard];
                let textToSpeak = '';
                let voice = '';
                let button = null;

                // Get the text based on language and card format
                if (language === 'french') {
                    button = this.speakBtn;
                    if (card.length === 5) {
                        // [frenchWord, englishWord, frenchExample, englishExample, grammarInfo]
                        textToSpeak = card[2] || card[0]; // Use French example if available, otherwise French word
                    } else if (card.length === 4) {
                        // [frenchWord, englishWord, frenchExample, englishExample]
                        textToSpeak = card[2] || card[0]; // Use French example if available, otherwise French word
                    } else if (card.length === 2) {
                        // [frenchPhrase, englishPhrase]
                        textToSpeak = card[0]; // Use French phrase
                    }
                    voice = 'French Female';
                } else if (language === 'english') {
                    button = this.speakEnglishBtn;
                    if (card.length === 5) {
                        // [frenchWord, englishWord, frenchExample, englishExample, grammarInfo]
                        textToSpeak = card[3] || card[1]; // Use English example if available, otherwise English word
                    } else if (card.length === 4) {
                        // [frenchWord, englishWord, frenchExample, englishExample]
                        textToSpeak = card[3] || card[1]; // Use English example if available, otherwise English word
                    } else if (card.length === 2) {
                        // [frenchPhrase, englishPhrase]
                        textToSpeak = card[1]; // Use English phrase
                    }
                    voice = 'UK English Female';
                }

                // Remove text within parentheses before speaking
                textToSpeak = this.removeParentheses(textToSpeak);

                // Debug logging
                console.log(`Speaking ${language}:`, textToSpeak);
                console.log('Voice:', voice);
                console.log('Button:', button);

                if (textToSpeak && typeof responsiveVoice !== 'undefined') {
                    // Check available voices for debugging
                    if (language === 'english') {
                        this.checkAvailableVoices();
                    }
                    this.speakWithResponsiveVoice(textToSpeak, voice, button, language);
                } else {
                    // Fallback for browsers without ResponsiveVoice
                    alert('Text-to-speech is not available. Please check your internet connection.');
                }
            }

            /**
             * Uses ResponsiveVoice library for text-to-speech
             * Handles voice selection, speech events, and error handling
             * @param {string} textToSpeak - The text to be spoken
             * @param {string} voice - The voice to use for speech
             * @param {HTMLElement} button - The button that triggered the speech
             * @param {string} language - The language being spoken
             */
            speakWithResponsiveVoice(textToSpeak, voice, button, language) {
                console.log('speakWithResponsiveVoice called with:', { textToSpeak, voice, language });
                
                // Disable the button while speaking and show force stop
                button.disabled = true;
                button.textContent = 'üîä Speaking...';
                this.forceStopBtn.style.display = 'inline-block';
                this.isSpeaking = true;

                // Configure ResponsiveVoice options
                const options = {
                    onstart: () => {
                        console.log('ResponsiveVoice speech started for', language);
                        console.log('Speech should be audible now');
                    },
                    onend: () => {
                        console.log('ResponsiveVoice speech ended for', language);
                        this.handleResponsiveVoiceEnd(button, language);
                    },
                    onerror: (error) => {
                        console.error('ResponsiveVoice error for', language, ':', error);
                        this.handleResponsiveVoiceError(button, language, error);
                    },
                    rate: 0.8,
                    pitch: 1.0,
                    volume: 1.0
                };

                // Speak the text
                try {
                    console.log('Calling responsiveVoice.speak with:', textToSpeak, voice, options);
                    responsiveVoice.speak(textToSpeak, voice, options);
                    
                    // For English, try using Web Speech API directly as fallback
                    /*
                    if (language === 'english') {
                        console.log('Trying Web Speech API directly for English');
                        this.speakWithWebSpeechAPI(textToSpeak, button, language);
                    } else {
                        responsiveVoice.speak(textToSpeak, voice, options);
                    }
                        */
                } catch (error) {
                    console.error('Error starting ResponsiveVoice:', error);
                    this.handleResponsiveVoiceError(button, language, error.message);
                }
            }

            /**
             * Uses Web Speech API for text-to-speech as a fallback
             * Handles voice selection, speech events, and error handling
             * @param {string} textToSpeak - The text to be spoken
             * @param {HTMLElement} button - The button that triggered the speech
             * @param {string} language - The language being spoken
             */
            speakWithWebSpeechAPI(textToSpeak, button, language) {
                console.log('Using Web Speech API for English:', textToSpeak);
                
                // Cancel any existing speech
                window.speechSynthesis.cancel();
                
                // Create utterance
                const utterance = new SpeechSynthesisUtterance(textToSpeak);
                utterance.lang = 'en-US';
                utterance.rate = 0.8;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                // Set up event handlers
                utterance.onstart = () => {
                    console.log('Web Speech API started for English');
                };
                
                utterance.onend = () => {
                    console.log('Web Speech API ended for English');
                    this.handleResponsiveVoiceEnd(button, language);
                };
                
                utterance.onerror = (error) => {
                    console.error('Web Speech API error for English:', error);
                    this.handleResponsiveVoiceError(button, language, error.error);
                };
                
                // Speak
                try {
                    window.speechSynthesis.speak(utterance);
                } catch (error) {
                    console.error('Error with Web Speech API:', error);
                    this.handleResponsiveVoiceError(button, language, error.message);
                }
            }

            /**
             * Handles the end of ResponsiveVoice speech
             * Re-enables the button and resets its text
             * @param {HTMLElement} button - The button that was disabled during speech
             * @param {string} language - The language that was spoken
             */
            handleResponsiveVoiceEnd(button, language) {
                // Re-enable button and hide force stop
                button.disabled = false;
                button.textContent = language === 'french' ? 'üîä Speak French' : 'üîä Speak English';
                this.forceStopBtn.style.display = 'none';
                this.isSpeaking = false;
            }

            /**
             * Handles errors from ResponsiveVoice speech synthesis
             * Re-enables the button and displays an error message
             * @param {HTMLElement} button - The button that was disabled during speech
             * @param {string} language - The language that was being spoken
             * @param {string} error - The error message
             */
            handleResponsiveVoiceError(button, language, error) {
                console.error('ResponsiveVoice failed:', error);
                
                // Re-enable button and hide force stop
                button.disabled = false;
                button.textContent = language === 'french' ? 'üîä Speak French' : 'üîä Speak English';
                this.forceStopBtn.style.display = 'none';
                this.isSpeaking = false;

                // Show error message
                const originalText = button.textContent;
                button.textContent = '‚ùå Failed';
                button.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = '';
                }, 2000);
            }

            /**
             * Forces all speech synthesis to stop
             * Cancels both ResponsiveVoice and Web Speech API speech
             * Re-enables buttons and resets the speaking state
             */
            forceStopSpeech() {
                console.log('Force stopping ResponsiveVoice speech');
                
                // Stop ResponsiveVoice
                responsiveVoice.cancel();

                // Reset all speech buttons
                this.speakBtn.disabled = false;
                this.speakBtn.textContent = 'üîä Speak French';
                this.speakBtn.style.background = '';
                this.speakEnglishBtn.disabled = false;
                this.speakEnglishBtn.textContent = 'üîä Speak English';
                this.speakEnglishBtn.style.background = '';
                this.forceStopBtn.style.display = 'none';

                // Reset state
                this.isSpeaking = false;
            }

            /**
             * Hides the text content on the flashcard
             * Adds a CSS class to blur or hide the text for testing purposes
             */
            hideText() {
                // Hide the flashcard content
                this.flashcard.style.display = 'none';
                // Show the show text button and hide the hide text button
                this.hideTextBtn.style.display = 'none';
                this.showTextBtn.style.display = 'inline-block';
            }

            /**
             * Shows the text content on the flashcard
             * Removes the CSS class that was hiding the text
             */
            showText() {
                // Show the flashcard content
                this.flashcard.style.display = 'block';
                // Show the hide text button and hide the show text button
                this.hideTextBtn.style.display = 'inline-block';
                this.showTextBtn.style.display = 'none';
            }

            /**
             * Updates the state of navigation buttons based on current position
             * Disables/enables buttons and updates their visual appearance
             */
            updateNavigationButtons() {
                // Update previous button
                const canGoBack = this.cardHistory.length > 0 && this.historyIndex > 0;
                this.previousBtn.disabled = !canGoBack;
                this.previousBtn.style.opacity = canGoBack ? '1' : '0.5';
                
                // Update next button
                const canGoForward = this.currentIndex < this.shuffledCards.length - 1;
                this.nextBtn.disabled = !canGoForward;
                this.nextBtn.style.opacity = canGoForward ? '1' : '0.5';
            }
        }

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const app = new FlashcardApp();
            // Hide Learn More link initially
            app.hideLearnMoreLink();
            
            // Initialize select synchronization
            app.sideSelect.value = app.currentSide;
            app.sideSelectMobile.value = app.currentSide;
            
            // Check available voices after a short delay to ensure ResponsiveVoice is loaded
            setTimeout(() => {
                app.checkAvailableVoices();
            }, 1000);
        });
    </script>
</body>
</html>
